#!/bin/sh
#
# Generate builtin-modules.c that #includes all module .c files
# for static (non-CONFIG_MODULES) builds, enabling full inlining.
#
# Each module directory must contain a Kbuild file and at least one
# .c source file. The source file should use module_init(fn) and
# module_exit(fn) macros from hpc/module.h.
#
# When built without CONFIG_MODULES, all module code is compiled into
# a single translation unit so the compiler can inline everything.
#
# Usage: gen-builtin-modules.sh <srctree> <output>

srctree="${1:-.}"
output="${2:-$srctree/modules/builtin-modules.c}"
moddir="$srctree/modules"

if [ ! -d "$moddir" ]; then
	exit 0
fi

modules=""
for dir in "$moddir"/*/; do
	[ -d "$dir" ] || continue
	name=$(basename "$dir")
	[ -f "$dir/Kbuild" ] || [ -f "$dir/Makefile" ] || continue

	if [ -f "$dir/$name.c" ]; then
		modules="$modules $name/$name.c"
	elif [ -f "$dir/module.c" ]; then
		modules="$modules $name/module.c"
	else
		for f in "$dir"/*.c; do
			[ -f "$f" ] || continue
			modules="$modules $name/$(basename "$f")"
			break
		done
	fi
done

tmp="$output.tmp"

cat > "$tmp" <<'EOF'
/* Auto-generated by scripts/gen-builtin-modules.sh -- do not edit */
#include <hpc/module.h>
EOF

for src in $modules; do
	printf '#include "%s"\n' "$src" >> "$tmp"
done

if [ -f "$output" ] && cmp -s "$tmp" "$output" 2>/dev/null; then
	rm -f "$tmp"
else
	mv -f "$tmp" "$output"
fi
